# Ruby を学ぶために必要な道具

最初のテキストは、とにかくがむしゃらにプログラムを書かせるような仕組みになっています。プログラミングの勉強において「写経」は大変重要ですが、写経させるプログラム例を作るのは至難の業です。この章では、そんな辛く苦しい時期を出来るだけ緩和させるような、便利な道具たちを紹介したいと思います。

##`Kernel.#p`

先に説明しておきますが、`Hoge#fuga`という表記があった時、それは「`Hoge`クラスのインスタンスメソッド`fuga`」を表します。「クラス」というのは、文字列とか、数値とか、配列とかそういうレベルで「モノ」(オブジェクト)を分類して、それぞれの設計図を定義したものです。`class Hoge`の場合、`Hoge.new`というコードを書くことで、設計図に基づいた実際の「モノ」を作ることができます。その「モノ」に対して"呼ぶ"ことで、その「モノ」に対して何らかの操作を行うのが、「インスタンスメソッド」です。
また、`Foo.#bar`という表記があった時、それは「`Foo`モジュールの`bar`メソッド」を表します。「モジュール」とは、「名前空間」とほぼ言い換えられるのではないかと思いますが、そもそもプログラミング演習I/IIでは「スコープ」の話がありませんね？　とりあえず「秋 C モジュール」の「モジュール」と一緒で、秋 BC 学期で定義されているプログラミング演習IIを秋 A で取ることはできない的な、そういうアレだと思っておいてください。
「じゃあ`Kernel.`って何じゃい」と思うでしょうが、今はあんまり気にしなくていいです (とりあえず、`Kernel.#hogehoge`があった時に、コード中で1行いきなり`hogehoge`とだけ書けば使うことができる、という意味で覚えておいてください。もちろん、引数を取る場合は`hogehoge(1, 2)`というように書きます。)。

授業のテキストの中では、とかく`print`メソッドが幅を利かせていて、出力系のメソッドはこれしか無いんじゃないかと思わされる勢いですが、もちろん他にもあります。行末に自動で改行を挿入してくれる`puts`、指定したフォーマットで適当に数字や文字列を埋め込んでくれる`printf`などいろいろありますが、Ruby を勉強する上で絶対に外せない出力系メソッドは何と言っても`p`メソッドです。`print`メソッドなど他の出力系のメソッドがとにかくただ普通に文字列を出力するのに対し、`p`メソッドはクラスの違いが分かるように適度に表現方法を変えて出力してくれます。例えば以下の通り。

	puts 1    #=> 1
	p 1       #=> 1   ←ただの 1 だからこれは整数
	puts "1"  #=> 1
	p "1"     #=> "1" ←ダブルクォーテーションが文字列を表している
              #         数字との違いが分かりやすい

見れば分かると思いますが、`hoge #=> fuga`という書き方は、「`hoge`を実行すると`fuga`になるよ」という意味です。上のように、整数や浮動小数点数や文字列などの、`puts`や`print`では違いが分からないことがあるオブジェクト同士の違いが分かるように出力してくれるので、とても便利です。Ruby で開発する上ではこの`p`デバッグはとても重要です。プログラムを書いていて、上手く動かないなと思ったら、気になる変数を片っぱしから`p`していきましょう。

……ちなみに、`Kernel.#p`は、引数として与えられたオブジェクトに対して、`Object#inspect`を呼び(返り値は文字列)、その文字列を標準出力に出力し改行する、というメソッドです。上記の「整数や浮動小数点数や文字列の違いが分かる」というのは、この`Object#inspect`のおかげです。
上記のコード例にもあるように、Ruby(だけでない多くのプログラミング言語)では`"hoge"`と書くことで、「hoge」という文字列を表します。また、`1`や`1.0`もそれぞれ整数の 1 や浮動小数点数の 1.0 を表します。
このような書き方のことを「リテラル」と呼びます。
ではリテラルでないものは何なのか。`foo = "bar"`を実行した上で、`puts foo`を実行すれば、「bar」と出力されます。この時の`foo`を「変数」と呼び、コード中に書かれた時、それは「foo」という文字列ではなく、「今`foo`という名前で呼ばれることになっている何か」という意味になります。
そして、「今`foo`という名前で呼ばれることになっている何かのリテラルを文字列でくれ」という表現が`foo.inspect`です。もっというと、「文字列をRubyコードとして評価してオブジェクトにしてくれ」という`Kernel.#eval`というのもありまして、オブジェクトから作ったリテラルを評価すればもとのリテラルと同じものが出来上がるので、`p eval(foo.inspect) #=> "bar"`なわけですね。これらが、プログラマが書くコードと、Ruby インタプリタが保持するオブジェクトとの相互変換ができる仕組みを作っているわけです……。

ついでに。上のコード例にもあるように、Ruby ではメソッドが取る引数の括弧を省略することが出来ます。これは関数型プログラミングにおいてよく見られる書き方ですが、それ以外のスタイルの言語で引数の括弧を省略することは稀です。Ruby においては出力系のメソッドに限って括弧を省略するような風潮がある感じがしますが、それ以外の場合は分かり辛いので、必ず括弧を付けるようにしましょう。括弧を付けることで「これは関数なんだ」というアピールにもなり、プログラムが読みやすくなります。ただし引数を取らないメソッドには括弧を付けないというのが一般的な Ruby のコーディング規約です。難しいですが段々慣れていくようにしましょう。

……ちなみに、引数の無いメソッドの呼び出しの括弧を省略できるのは、Ruby 以外ではまずありません。Ruby とよく比較されるスクリプト言語である Python ではどうかというと、

	import random
	def foo():
		print("foo")
	def bar():
		print("bar")
	random.choice([foo, bar])()

というようなコードを書けます。これは何をしているのかというと、ランダムに`foo()`を実行するのか`bar()`を実行するのか選んでいるのです。
そのようなことが可能なのは、`foo`や`bar`が、メソッド呼び出しではなく、メソッドそのもののオブジェクトを指し示す識別子(変数であると思って良いです)であるからです。
Ruby で括弧省略になれると、かなりハマります。気をつけて。

ちなみに、 Ruby で同等のコードを書くと、こうなります。

	def foo
		puts "foo"
	end
	def bar
		puts "bar"
	end
	self.send([:foo, :bar].sample)

## irb

irb は Rubyist の最高の友達です。たぶん。

	Z:\> irb
	irb(main):001:0> hoge = 1
	=> 1
	irb(main):002:0> def foo(x, y)
	irb(main):003:1>   x + y
	irb(main):004:1> end
	=> nil
	irb(main):005:0> foo(hoge, 2)
	=> 3
	irb(main):006:0>

`p`メソッドのお話で「関数型」のお話がありましたが、irb というのは、REPL と呼ばれるものの一種です。REPL は関数型言語で非常によく使われ、多くのスクリプト言語で同様のものが作られた、という背景があります。「Ruby の REPL」すなわち irb というわけですね。
REPL とは何の略であるか、というと、 Read-Eval-Print Loop の頭文字です。コマンドプロンプトで(といいつつ、実は上の irb のデモは gnome-terminal でやってますけど)、irb コマンドを実行すると使えます。
標準入力からコマンドを読み取る(read)と、入力された文字列を Ruby プログラムとして評価(evaluate, eval)して、値をリテラルの形で表示(print)します。それを繰り返して(loop)くれます。
変数やメソッド定義などの情報は、irb がずっと覚えていてくれて、上のように 1 行目で初期化した変数や 2-4 行目で定義したメソッドを 5 行目で使うというようなことができるわけです。
さて、ところで REPL は`Kernel.#eval`と`Kernel.#p`に関係があります(`Kernel.#print`は全く関係ないので忘れてください)。read はどこいったんだというと、`Kernel.#gets`よりはもう少し賢い`Readline::readline`というものを使っているはずですが、でも、すごく乱暴なことを言うと、gets と eval と p で超簡易版 REPL を実装できます。

	loop.with_object(lambda{ binding }.call){|_, scope|
	  break if not gets # if文は後ろに書いて前を評価するかどうか分岐できる
	  p eval($_, scope) # $_は最後のgetsの返り値を覚えているグローバル変数
	}

どうでしょうか、Read(`Kernel.#gets`)、Eval(`Kernel.#eval`)、Print(`Kernel.#p`)、Loop(`Kernel.#loop`)になってますよね(`Enumerator#with_object`だの`lambda`だの`Kernel.#binding`だのは今はとりあえず「そういうものだ」ということにしておいてください。変数のスコープというものと関係があります)。
ただし、この超簡易版だと、上記の irb デモでやったような、メソッドを複数行に渡って書くという芸当ができません。なぜなら、`Kernel.#eval`にメソッド定義をさせたければ、`def メソッド名(引数)`からそれに対応する`end`までのすべての行を1つの String にして評価させなければならないからです。`def foo(x, y); x + y; end`と強引に書けば可能ではありますが、実用的ではありません。
irb デモの 3-4 行目の部分に注目してください。`irb(main):003:1>`というように、> の前にある数字が 1 になっていますね？　ほかは 0 です。この数字は何を表しているかというと、「ネストの深さ」です。Ruby を書くときのインデントの深さに対応します。irb は「`def`が`end`で閉じるまで`eval`しないで読み続ける」という判断ができるのです。

さて、irb がナニモノであるのか、おおよそ掴んで頂いたところで、これが何の役に立つのかというお話ですが、例えば正規表現が目的の文字列をきちんと拾えるかテストしたい時、irb を使うのです。

	irb(main):001:0> "hoge123" =~ /^\w+$/
	=> 0
	irb(main):002:0> "*****" =~ /^\w+$/
	=> nil
	irb(main):003:0>

`/^\w+$/`という正規表現は、言葉で説明すると(ところで私見だけれど、正規表現は言葉で説明できるのが望ましいと思います)、「始まりから終わりまでが、英数字か\_を1個以上並べた文字列である」ですが、このように、実際にマッチさせてみて確認するわけです。
このように、細かい部品で実験しながら組み立てていく、という「ボトムアップ」なプログラミングに必要不可欠なツールが REPL なのです。

ちなみに、wirble とか pry とかで調べると幸せになれるとかいう話がある。
