* Ruby を学ぶために必要な道具

最初のテキストは、とにかくがむしゃらにプログラムを書かせるような仕組みになっています。プログラミングの勉強において「写経」は大変重要ですが、写経させるプログラム例を作るのは至難の業です。この章では、そんな辛く苦しい時期を出来るだけ緩和させるような、便利な道具たちを紹介したいと思います。

** =Kernel.#p=

先に説明しておきますが、 =Hoge#fuga= という表記があった時、それは「 =Hoge= クラスのインスタンスメソッド =fuga= 」を表します。「クラス」というのは、文字列とか、数値とか、配列とかそういうレベル「モノ」(オブジェクト)を分類して、それぞれの設計図を定義したものです。 =class Hoge= の場合、 =Hoge.new= というコードを書くことで、設計図に基づいた実際の「モノ」を作ることができます。その「モノ」に対して"呼ぶ"ことで、その「モノ」に対して何らかの操作を行うのが、「インスタンスメソッド」です。
また、 =Foo.#bar= という表記があった時、それは「=Foo= モジュールの =bar= メソッド」を表します。「モジュール」とは、「名前空間」とほぼ言い換えられるのではないかと思いますが、そもそもプログラミング演習I/IIでは「スコープ」の話がありませんね? とりあえず「秋Cモジュール」の「モジュール」と一緒で、秋BC学期で定義されているプログラミング演習IIを秋Aで取ることはできない的な、そういうアレだと思っておいてください。
「じゃあ =Kernel.= って何じゃい」と思うでしょうが、今はあんまり気にしなくていいです (とりあえず、 =Kernel.#hogehoge= があった時に、コード中で1行いきなり =hogehoge= とだけ書けば使うことができる、という意味で覚えておいてください。もちろん、引数を取る場合は =hogehoge(1, 2)= というように書きます。)。

授業のテキストの中では、とかく =print= メソッドが幅を利かせていて、出力系のメソッドはこれしか無いんじゃないかと思わされる勢いですが、もちろん他にもあります。行末に自動で改行を挿入してくれる =puts= 、指定したフォーマットで適当に数字や文字列を埋め込んでくれる =printf= などいろいろありますが、Ruby を勉強する上で絶対に外せない出力系メソッドは何と言っても =p= メソッドです。 =print= メソッドなど他の出力系のメソッドがとにかくただ普通に文字列を出力するのに対し、 =p= メソッドはクラスの違いが分かるように適度に表現方法を変えて出力してくれます。例えば以下の通り。

#+BEGIN_SRC ruby
puts 1    #=> 1
p 1       #=> 1   ←ただの 1 だからこれは整数
puts "1"  #=> 1
p "1"     #=> "1" ←ダブルクォーテーションが文字列を表している
          #         数字との違いが分かりやすい
#+END_SRC

見れば分かると思いますが、 =hoge #=> fuga= という書き方は、「 =hoge= を実行すると =fuga= になるよ」という意味です。上のように、整数や浮動小数点数や文字列などの、putsやprintでは違いが分からないことがあるオブジェクト同士の違いが分かるように出力してくれるので、とても便利です。Ruby で開発する上ではこの =p= デバッグはとても重要です。プログラムを書いていて、上手く動かないなと思ったら、気になる変数を片っぱしから =p= していきましょう。

…ちなみに、 =Kernel.#p= は、引数として与えられたオブジェクトに対して、 =Object#inspect= を呼び(返り値は文字列)、その文字列を標準出力に出力し改行する、というメソッドです。上記の「整数や浮動小数点数や文字列の違いが分かる」というのは、この =Object#inspect= のおかげです。
上記のコード例にもあるように、Ruby(だけでない多くのプログラミング言語)では ="hoge"= と書くことで、「hoge」という文字列を表します。また、 =1= や =1.0= もそれぞれ1や1.0を表します。
このような書き方のことを「リテラル」と呼び、ではリテラルでないものは何なのかというと、 =foo = "bar"= を実行した上で、 =puts foo= を実行すれば、「bar」と出力されます。この時の =foo= を「変数」と呼び、コード中に書かれた時、それは「foo」という文字列ではなく、「今 =foo= という名前で呼ばれることになっている何か」という意味になります。
そして、「今 =foo= という名前で呼ばれることになっている何かのリテラルを文字列でくれ」というのが =foo.inspect= です。もっというと、「文字列のリテラルをオブジェクトにしてくれ」という =Kernel.#eval= というのもありまして =p eval(foo.inspect) #=> "bar"= なわけですね。これらが、プログラマが書くコードと、Rubyインタプリタが保持するオブジェクトとの相互変換ができる仕組みを作っているわけです…。

ついでに。上のコード例にもあるように、Ruby ではメソッドが取る引数の括弧を省略することが出来ます。これは関数型プログラミングにおいてよく見られる書き方ですが、それ以外のスタイルの言語で引数の括弧を省略することは稀です。Ruby においては出力系のメソッドに限って括弧を省略するような風潮がある感じがしますが、それ以外の場合は分かり辛いので、必ず括弧を付けるようにしましょう。括弧を付けることで「これは関数なんだ」というアピールにもなり、プログラムが読みやすくなります。ただし引数を取らないメソッドには括弧を付けないというのが一般的な Ruby のコーディング規約です。難しいですが段々慣れていくようにしましょう。

** irb

irbはRubyistの最高の友達です。たぶん。

#+BEGIN_SRC
Z:\> irb
irb(main):001:0> hoge = 1
=> 1
irb(main):002:0> def foo(x, y)
irb(main):003:1>   x + y
irb(main):004:1> end
=> nil
irb(main):005:0> foo(hoge, 2)
=> 3
irb(main):006:0>
#+END_SRC

=p= メソッドのお話で「関数型」のお話がありましたが、irbというのは、REPLと呼ばれるものの一種で関数型言語で非常によく使われ、スクリプト言語にも同様のものが取り入れられた、という背景があります。
REPLとは何の略であるか、というと、 Read-Eval-Print Loopの頭文字です。コマンドプロンプトで(といいつつ、実は上のirbのデモはgnome-terminalでやってますけど)、irbコマンドを実行すると使えます。
標準入力からコマンドを入れると、入力された文字列をRubyプログラムとして評価(evaluate, eval)して、値をリテラルの形で表示(print)します。それを繰り返してくれます。
変数やメソッド定義などの情報は、irbがずっと覚えていてくれて、上のように1行目で初期化した変数や2〜4行目で定義したメソッドを5行目で使うというようなことができるわけです。
さて、ところでREPLは =Kernel.#eval= と =Kernel.#p= に関係があります( =Kernel.#print= は全く関係ないので忘れてください)。readはどこいったんだというと、 =Kernel.#gets= よりはもう少し賢い =Readline::readline= というものを使っているはずですが、でも、すごく乱暴なことを言うと、getsとevalとpで超簡易版REPLを実装できます。

#+BEGIN_SRC Ruby
loop.with_object(lambda{ binding }.call){|_, scope|
  break if not gets # if文は後ろに書いて前を評価するかどうか分岐できる
  p eval($_, scope) # $_は最後のgetsの返り値を覚えているグローバル変数
}
#+END_SRC

どうでしょうか、Read(Kernel.#gets)、Eval(Kernel.#eval)、Print(Kernel.#p)、Loop(Kernel.#loop)になってますよね(with_objectだのlambdaだのbindingだのは今はとりあえず「そういうものだ」ということにしておいてください。変数のスコープというものと関係があります)。
ただし、この超簡易版だと、上記のirbデモでやったような、メソッドを複数行に渡って書くという芸当ができません。なぜなら、Kernel.#evalにメソッド定義をさせたければ、 =def メソッド名(引数)= からそれに対応する =end= までのすべての行を1つのStringにして評価させなければならないからです。 =def foo(x, y); x + y; end= と強引に書けば可能ではありますが、実用的ではありません。
irbデモの3-4行目の部分に注目してください。 =irb(main):003:1> = というように、>の前にある数字が1になっていますね? ほかは0です。この数字は何を表しているかというと、「ネストの深さ」です。Rubyを書くときのインデントの深さに対応します。irbは「defがendで閉じるまでevalしないで読み続ける」という判断ができるのです。

さて、irbがナニモノであるのか、おおよそ掴んで頂いたところで、これが何の役に立つのかというお話ですが、例えば正規表現が目的の文字列をきちんと拾えるかテストしたい時、irbを使うのです。


#+BEGIN_SRC
irb(main):001:0> "hoge123" =~ /^\w+$/                                                                                                                                         => 0
irb(main):002:0> "*****" =~ /^\w+$/
=> nil
irb(main):003:0>
#+END_SRC

=/^\w+$/= という正規表現は、言葉で説明すると(ところで私見だけれど、正規表現は言葉で説明できるのが望ましいと思います)、「始まりから終わりまでが、英数字か_を1個以上並べた文字列である」ですが、このように、実際にマッチさせてみて確認するわけです。
このように、細かい部品で実験しながら組み立てていく、という「ボトムアップ」なプログラミングに必要不可欠なツールがREPLなのです。
